# Документация: data/local/download

Данный модуль отвечает за синхронизацию контента между удаленным хранилищем и локальной файловой системой Android, обеспечивая офлайн-доступ к медиафайлам сущностей Game, Film и Song.

---

## 1. Организация данных в Storage (Backend)

Файлы распределены по двум основным бакетам в зависимости от типа контента. Внутри бакетов для удобства реализована структура по категориям:

* **Bucket "video":** Содержит подпапки `films/`, `songs/`, `games/`.
* **Bucket "audio":** Содержит подпапки `films/`, `songs/`, `games/`.

**Метаданные сущностей:**
Связь объекта в БД с физическим файлом осуществляется через поля `audio_path` и `video_path`. В базе путь хранится относительно бакета (например, `songs/track_01.mp3`).

**API Service:**
Реализованы специализированные методы скачивания. При вызове метода для аудио бакет `"audio"` подставляется автоматически; для видео — бакет `"video"`.

---

## 2. Иерархия Downloadable-сущностей

Так как медиа-структуры разных типов контента различаются (например, у `Song` может быть несколько аудио-файлов и поле `segment_type`, а у `Game` — строго один), была внедрена универсальная иерархия наследования.

### Базовый класс: `DownloadableMedia`
Абстрактный предок с единственным методом:
`abstract suspend fun download(apiService: ApiService, daos: DaoBundle): DownloadResult`

### Реализации:
* **Наследники:** `DownloadableFilm`, `DownloadableGame`, `DownloadableSongAudio`, `DownloadableSongVideo`.
* **Конструктор:** Принимает параметры, необходимые для идентификации сущности, и целевой объект `File` для сохранения.
* **Управление DAO:** В метод `download` передается полная сборка всех DAO (`DaoBundle`). Это архитектурное решение принято, так как каждый наследник использует свою специфичную DAO для обновления локальных путей.

---

## 3. Универсальный загрузчик: UnifiedMediaDownloader

Класс `UnifiedMediaDownloader` является центральной точкой управления очередью загрузок.

### Инициализация
В конструктор передаются:
* `apiService` и `daos`.
* Базовые директории для аудио и видео, полученные через `AndroidFileProvider` (сохранение в `context.getExternalFilesDir`).

### Логика функции `downloadAll()`
Функция возвращает `Flow<DownloadProgress>` и работает по следующему алгоритму:

1.  **Сбор данных:** Из всех DAO запрашиваются сущности, у которых еще не заполнены локальные пути.
2.  **Маппинг:** Полученные Entity маппятся в объекты `DownloadableMedia`.
3.  **Параллельная загрузка:** * Используется `channelFlow` для обработки потока данных.
    * **Ограничение параллельности:** Применен семафор (по умолчанию **на 3 потока**). Это предотвращает перегрузку сети и устройства, сохраняя высокую эффективность.
    * **Обработка:** Каждый элемент обрабатывается в `coroutineScope` параллельно, результаты эмиттятся в Flow.

---

## 4. Результаты и состояния

### Статусы загрузки (`DownloadResult`)
Каждая атомарная операция скачивания возвращает одно из состояний:
* `Success` — файл скачан, локальный путь (например, `local_audio_path`) обновлен в БД.
* `Error` — ошибка сети или записи.
* `Skipped` — файл уже существует или загрузка не требуется.

### Прогресс для UI (`DownloadProgress`)
* `InProgress` — передает текущее состояние для Progress Bar.
* `Completed` — содержит итоговую статистику по количеству удачных и неудачных операций.

---

## 5. Технические заметки
* **Создание папок:** Сами downloadable-сущности не отвечают за создание папок. Директории создаются "уровнем выше" в загрузчике перед передачей объекта `File` в конструктор сущности.
* **Тестирование:** Тесты подтвердили, что лимит в 3-4 потока является "золотой серединой" между скоростью загрузки и стабильностью соединения.